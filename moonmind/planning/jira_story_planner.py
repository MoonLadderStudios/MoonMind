"""Skeleton for planning Jira stories from high level text."""

from __future__ import annotations

import json
import logging
from typing import Any, List, Optional
import time

from pydantic import BaseModel, Field

from moonmind.config.settings import AppSettings
from moonmind.factories.google_factory import get_google_model


class JiraStoryPlannerError(Exception):
    """Raised for errors during LLM planning or JSON parsing."""


class StoryDraft(BaseModel):
    summary: str = Field(..., description="Short summary of the story")
    description: str = Field(..., description="Detailed description")
    issue_type: str = Field(..., description="Jira issue type")
    story_points: Optional[int] = Field(None, description="Story points estimate")
    labels: List[str] = Field(default_factory=list, description="Labels to apply")
    key: Optional[str] = Field(None, description="Created Jira issue key")


class JiraStoryPlanner:
    """Convert a plan description into Jira issues.

    Parameters
    ----------
    plan_text : str
        Text describing the overall plan or feature to implement.
    jira_project_key : str
        Key of the Jira project where issues should be created.
    dry_run : bool, optional
        If ``True``, no changes will be made in Jira. Defaults to ``True``.
    llm_model : Any, optional
        Language model used for text processing.
    logger : logging.Logger, optional
        Logger for debug and progress messages.
    **jira_kwargs : Any
        Additional arguments forwarded to the Jira client when implemented.
    """

    def __init__(
        self,
        plan_text: str,
        jira_project_key: str,
        dry_run: bool = True,
        llm_model: Optional[Any] = None,
        logger: Optional[logging.Logger] = None,
        **jira_kwargs: Any,
    ) -> None:
        self.logger = logger or logging.getLogger(__name__)

        if not plan_text:
            raise ValueError("plan_text is required")
        if not jira_project_key:
            raise ValueError("jira_project_key is required")

        self.plan_text = plan_text
        self.jira_project_key = jira_project_key
        self.dry_run = dry_run
        self.llm_model = llm_model
        self.jira_kwargs = jira_kwargs

        # Load Jira credentials from application settings
        settings = AppSettings()
        self.jira_url = settings.atlassian.atlassian_url
        self.jira_username = settings.atlassian.atlassian_username
        self.jira_api_key = settings.atlassian.atlassian_api_key

        # Placeholder for future Jira client
        self.jira_client = None

    def _build_prompt(self, plan_text: str) -> list:
        """Build LLM prompt messages from raw plan text.

        Parameters
        ----------
        plan_text : str
            The raw text describing the plan to convert into Jira stories.

        Returns
        -------
        list of Message
            A list containing the system and user messages ready for an LLM
            chat completion request.
        """
        from moonmind.schemas.chat_models import Message

        system_prompt = (
            "You are a Jira planning assistant. "
            "Return ONLY a JSON array of issues using the fields "
            "'summary', 'description', 'issue_type', 'story_points', and "
            "'labels'."
        )

        return [
            Message(role="system", content=system_prompt),
            Message(role="user", content=plan_text),
        ]

    def _call_llm(self, prompt: list) -> List[StoryDraft]:
        """Send prompt to the LLM and parse the JSON response.

        Parameters
        ----------
        prompt : list
            List of chat messages generated by ``_build_prompt``.

        Returns
        -------
        List[StoryDraft]
            Validated list of story drafts returned by the LLM.

        Raises
        ------
        JiraStoryPlannerError
            If the LLM call fails or the response is not valid JSON.
        """
        model = self.llm_model
        if model is None:
            try:
                model = get_google_model()
            except (
                ImportError,
                ValueError,
            ) as e:  # pragma: no cover - expected failure types
                self.logger.exception("Failed to initialize LLM model: %s", e)
                raise JiraStoryPlannerError(
                    f"Failed to initialize LLM model: {e}"
                ) from e

        try:
            response = model.generate_content(prompt)
        except Exception as e:
            self.logger.exception("LLM generation error: %s", e)
            raise JiraStoryPlannerError(f"LLM generation error: {e}") from e

        response_text: Optional[str] = None
        try:
            if hasattr(response, "candidates") and response.candidates:
                first_candidate = response.candidates[0]
                if (
                    getattr(first_candidate, "content", None)
                    and first_candidate.content.parts
                ):
                    text_parts = [
                        part.text
                        for part in first_candidate.content.parts
                        if hasattr(part, "text") and part.text
                    ]
                    if text_parts:
                        response_text = "".join(text_parts)

            if not response_text and hasattr(response, "text"):
                response_text = response.text
        except Exception as e:  # pragma: no cover - unexpected failure structure
            self.logger.exception("Error extracting text from LLM response: %s", e)
            raise JiraStoryPlannerError(f"Invalid LLM response format: {e}") from e

        if not response_text:
            raise JiraStoryPlannerError("LLM returned no text content")

        try:
            parsed = json.loads(response_text)
        except Exception as e:
            self.logger.exception("Invalid JSON from LLM: %s", e)
            raise JiraStoryPlannerError(f"Invalid JSON from LLM: {e}") from e

        try:
            return [StoryDraft.model_validate(item) for item in parsed]
        except Exception as e:
            self.logger.exception("Story validation failed: %s", e)
            raise JiraStoryPlannerError(f"Story validation failed: {e}") from e

    def _get_jira_client(self, **overrides: Any):
        """Initialize and authenticate a Jira client.

        Parameters
        ----------
        **overrides : Any
            Optional keyword arguments that override default client configuration.

        Returns
        -------
        atlassian.Jira
            Authenticated Jira client instance.

        Raises
        ------
        JiraStoryPlannerError
            If authentication fails.
        """
        from atlassian import Jira

        config = {
            "url": self.jira_url,
            "username": self.jira_username,
            "password": self.jira_api_key,
            "cloud": True,
            "backoff_and_retry": True,
            "max_backoff_seconds": 16,
            "max_backoff_retries": 3,
        }
        config.update(overrides)

        try:
            client = Jira(**config)
            client.myself()  # Trigger authentication
        except Exception:  # pragma: no cover - network/credential errors
            # Avoid logging credentials from the exception message.
            self.logger.exception("Jira authentication failed")
            raise JiraStoryPlannerError(
                f"Failed to authenticate with Jira at {self.jira_url}"
            ) from None

        return client

    def _resolve_story_points_field(self, jira_client: Any) -> str:
        """Return the custom field id used for story points.

        Parameters
        ----------
        jira_client : Any
            Authenticated Jira client.

        Returns
        -------
        str
            The custom field id for story points.

        Raises
        ------
        JiraStoryPlannerError
            If the field cannot be located.
        """

        if getattr(self, "_story_points_field_id", None):
            return self._story_points_field_id  # type: ignore[attr-defined]

        try:
            fields = jira_client.get_all_fields()
        except Exception as e:  # pragma: no cover - network errors
            self.logger.exception("Failed to retrieve Jira fields: %s", e)
            raise JiraStoryPlannerError(f"Failed to retrieve Jira fields: {e}") from e

        for field in fields:
            name = str(field.get("name", "")).lower()
            field_type = field.get("schema", {}).get("type")
            if name == "story points" and field_type == "number":
                field_id = field.get("id")
                if field_id:
                    self._story_points_field_id = field_id
                    return field_id

        raise JiraStoryPlannerError("Story points field not found")

    def _create_issues(self, drafts: List[StoryDraft]) -> List[StoryDraft]:
        """Create Jira issues from the given drafts.

        Parameters
        ----------
        drafts : List[StoryDraft]
            Draft issue objects to create in Jira.

        Returns
        -------
        List[StoryDraft]
            Drafts updated with their created issue keys.
        """

        if not drafts:
            return []

        if self.dry_run:
            return drafts

        jira = self.jira_client or self._get_jira_client(**self.jira_kwargs)
        story_points_field = self._resolve_story_points_field(jira)

        created: List[StoryDraft] = []

        for batch_start in range(0, len(drafts), 50):
            batch = drafts[batch_start : batch_start + 50]
            issue_updates = []
            for draft in batch:
                fields = {
                    "project": {"key": self.jira_project_key},
                    "summary": draft.summary,
                    "description": draft.description,
                    "issuetype": {"name": draft.issue_type},
                }
                if draft.story_points is not None:
                    fields[story_points_field] = draft.story_points
                if draft.labels:
                    fields["labels"] = draft.labels
                issue_updates.append({"fields": fields})

            # Attempt bulk creation with retries on 429
            attempts = 0
            while True:
                try:
                    bulk_resp = jira.issue_create_bulk(issue_updates)
                    break
                except Exception as e:  # pragma: no cover - network errors
                    if (
                        getattr(e, "status", None) == 429
                        or getattr(e, "status_code", None) == 429
                        or "429" in str(e)
                    ) and attempts < 3:
                        time.sleep(2**attempts)
                        attempts += 1
                        continue
                    raise

            bulk_issues = []
            if isinstance(bulk_resp, dict):
                bulk_issues = bulk_resp.get("issues", [])
            elif isinstance(bulk_resp, list):
                bulk_issues = bulk_resp

            for idx, draft in enumerate(batch):
                key = None
                if idx < len(bulk_issues) and isinstance(bulk_issues[idx], dict):
                    key = bulk_issues[idx].get("key")
                if not key:
                    single_attempts = 0
                    while True:
                        try:
                            single_resp = jira.create_issue(fields=issue_updates[idx]["fields"])
                            if isinstance(single_resp, dict):
                                key = single_resp.get("key")
                            break
                        except Exception as e:  # pragma: no cover - network errors
                            if (
                                getattr(e, "status", None) == 429
                                or getattr(e, "status_code", None) == 429
                                or "429" in str(e)
                            ) and single_attempts < 3:
                                time.sleep(2**single_attempts)
                                single_attempts += 1
                                continue
                            raise
                draft.key = key
                created.append(draft)

        return created
