# Task Proposal Queue (Worker Follow-Up Recommendations)

Status: Implemented
Owners: MoonMind Engineering
Last Updated: 2026-02-18
Related: `docs/TaskArchitecture.md`, `docs/TaskQueueSystem.md`, `docs/TaskUiArchitecture.md`, `api_service/static/task_dashboard/dashboard.js`

---

## 1. Purpose

Workers often finish a Task and immediately see follow-up work (security hardening, refactors, performance wins, missing tests, debt cleanup). MoonMind needs a **first-class mechanism** for workers to submit these ideas into a **human-reviewed proposal queue**, with a **one-click promotion** path that turns a proposal into an executable Task (Agent Queue job `type="task"`) with minimal or no customization.

MoonMind already has:

* A canonical Task contract and queue representation (`type="task"` + canonical payload)
* Queue REST endpoints to create/list/detail jobs under `/api/queue`
* A thin Task Dashboard shell and runtime config pattern (`sources.queue.*`, `sources.orchestrator.*`)

This design adds **Task Proposals** as a parallel control-plane object that can be **promoted** into the existing queue.

---

## 2. Goals and Non-Goals

### Goals

1. **Workers can submit proposals** programmatically immediately after finishing a job.
2. **Humans can review proposals** in the Task Dashboard and via REST API.
3. **One-click “Promote to Task”** creates a queue job `type="task"` using a stored canonical payload, leveraging existing queue submission semantics.
4. **Promotion is reliable**: proposal payloads are validated against the canonical Task contract rules used by the queue before any job is enqueued.
5. **Auditability**: proposal origin and decision trail are persisted (who proposed, from which job/run, who promoted/dismissed).

### Non-Goals

* Auto-executing proposals without human review.
* Replacing queue events/artifacts. Proposals can reference them, not duplicate them.
* Building a full issue tracker. This is a “convert to Task” funnel.

---

## 3. Key Decision: Separate Proposal Store (Not Agent Queue Jobs)

**Decision:** Add a dedicated `task_proposals` table and API, instead of representing proposals as queue jobs.

**Why:**

* Queue jobs have lifecycle states (`queued`, `running`, `succeeded`, `failed`, `cancelled`, `dead_letter`) that do not map cleanly to proposal triage states.
* The dashboard’s aggregated “active work” pulls queued/running queue jobs without type filtering, so proposals stored as queued jobs would pollute the main view.
* Worker claim logic selects `status == queued` and will claim any allowed types. A separate table avoids accidental claiming.

---

## 4. Data Model

### 4.1 `task_proposals` table

| Column | Type | Notes |
| --- | --- | --- |
| `id` | UUID, PK | Generated server-side.
| `status` | ENUM (`open`, `promoted`, `dismissed`, `accepted`, `rejected`) | See 4.2 for transitions.
| `title` | text | Required, max length 256 for UI readability.
| `summary` | text | Markdown allowed; always stored after secret scrubbing.
| `category` | text | Optional (`security`, `performance`, `refactor`, `feature`, `tests`, etc.).
| `tags` | `jsonb[]` | Optional; values lowercased before storage.
| `repository` | text | Normalized repository string for filtering (derived from payload).
| `created_at` / `updated_at` | timestamptz | Default `now()` via trigger.
| `proposed_by_worker_id` | text | Worker identity string (may be agent UUID or hostname).
| `proposed_by_user_id` | UUID | Nullable; set when humans submit proposals.
| `origin_source` | text | Enum-like: `queue`, `orchestrator`, `workflow`, `manual`.
| `origin_id` | UUID | Nullable; queue job id, orchestrator run id, etc.
| `origin_metadata` | jsonb | Optional: branch, PR URL, artifact hints, failure summaries.
| `task_create_request` | jsonb | Required canonical queue create envelope (see below).
| `promoted_job_id` | UUID | References `agent_jobs.id`; unique.
| `promoted_at` | timestamptz | Nullable.
| `promoted_by_user_id` | UUID | Nullable; auth user who promoted.
| `decided_by_user_id` | UUID | Nullable; reviewer who made the last decision (promotion or dismissal).
| `decision_note` | text | Optional annotation for dismissal/promote decisions.

**Task template (`task_create_request`)**

Stores a queue-create envelope compatible with `POST /api/queue/jobs` (`CreateJobRequest`). Example:

```json
{
  "type": "task",
  "priority": 0,
  "maxAttempts": 3,
  "affinityKey": null,
  "payload": {
    /* CanonicalTaskPayload (validated via Task contract helper) */
  }
}
```

Only `type="task"` is accepted. Defaults (priority, attempts) are stored exactly as provided so promotion can be fully idempotent.

**Indexes & Constraints**

* B-tree on `status, created_at` to drive dashboard pagination.
* Partial index on `status='open' AND origin_source='queue'` to power scoped list queries.
* Unique index on `promoted_job_id` to prevent multiple proposals pointing at the same queue job record.
* Optional hash/dedup index on `(lower(repository), digest(normalized_title))` for Phase 2 similar-proposal detection.

### 4.2 Proposal state machine

| From | To | Trigger |
| --- | --- | --- |
| `open` | `promoted` | Successful call to promote endpoint.
| `open` | `dismissed` | Reviewer dismissal.
| `open` | `accepted` / `rejected` | Optional triage outcome without promotion.
| `promoted` | — | Terminal state; repeated promote returns same job id.

State transitions require optimistic locking on `updated_at` or `status` to avoid stale updates during concurrent reviews.

---

## 5. API Surface

All endpoints live under `/api/proposals` (OpenAPI tag: `task-proposals`). JSON uses camelCase to align with existing queue APIs.

### 5.1 Create proposal (worker or user)

`POST /api/proposals`

Auth:

* Worker auth (`X-MoonMind-Worker-Token`) with `capabilities` containing `proposals_write` (see §11).
* User auth (session/cookie or PAT) for manual proposals.

Request body mirrors the existing schema:

```json
{
  "title": "Add unit tests for new auth validation branch",
  "summary": "Follow-up should add regression tests for ssh URL edge cases.",
  "category": "tests",
  "tags": ["auth", "git", "regression"],
  "origin": { "source": "queue", "id": "9b7a2c5a-..." },
  "taskCreateRequest": {
    "type": "task",
    "priority": 0,
    "maxAttempts": 3,
    "payload": {
      "repository": "MoonLadderStudios/MoonMind",
      "task": {
        "instructions": "Add regression tests...",
        "skill": { "id": "auto", "args": {} },
        "runtime": { "mode": "codex" },
        "git": { "startingBranch": null, "newBranch": null },
        "publish": { "mode": "branch" }
      }
    }
  }
}
```

Server behavior:

1. **Secret redaction** via `SecretRedactor` for title, summary, `taskCreateRequest.payload`.
2. **Validation** using canonical Task contract helper (same path as queue jobs).
3. **Normalization**: tag lowercasing, default category fallback to `"general"`.
4. Persist record as `status=open` (audited via `proposed_by_*`).
5. Emit `proposals.created.count` metric.

### 5.2 List proposals (human review)

`GET /api/proposals?status=open&repository=MoonLadderStudios/MoonMind&limit=50&cursor=...`

* Auth: user.
* Supports filters: `status`, `category`, `repository` (resolved from payload), `originSource`.
* Returns `{ "items": [ ProposalModel ], "nextCursor": "..." }` for stable pagination.

### 5.3 Get proposal detail

`GET /api/proposals/{proposalId}` (user auth)

Returns the proposal plus computed `taskPreview` fields (repository, runtime mode, publish mode) to simplify dashboard rendering.

### 5.4 Promote proposal to Task

`POST /api/proposals/{proposalId}/promote`

Body (optional overrides):

```json
{ "priority": 10, "maxAttempts": 5 }
```

Server behavior:

1. Reject if `status != open` unless already `promoted` (idempotent path returns existing job record).
2. Merge overrides onto stored `task_create_request` (priority/attempts only for MVP).
3. Call the queue job creation helper used by `POST /api/queue/jobs`.
4. Persist `promoted_job_id`, `promoted_at`, `promoted_by_user_id`, set status `promoted`.
5. Emit `proposals.promoted.count` metric tagged with category and repository.
6. Respond with queue job payload so UI can redirect to `/tasks/queue/{jobId}`.

### 5.5 Dismiss proposal

`POST /api/proposals/{proposalId}/dismiss`

Body: `{ "note": "not needed" }` (optional)

Sets status `dismissed`, stores `decision_note`, increments `proposals.dismissed.count`.

### 5.6 Error model

* `400` for validation failures (propagate canonical contract errors).
* `401` / `403` for auth/capability failures.
* `404` when proposal id unknown.
* `409` when concurrent promote/dismiss occurs (retry safe via `If-Unmodified-Since` header or ETag).

---

## 6. Worker Integration

### 6.1 When proposals are generated

Workers can emit proposals:

* At the end of a Task execution (after publish stage completes) when improvements are obvious.
* On failure (e.g., “add retry/backoff”, “fix flaky test”).
* On detection of risk (dependency vulnerabilities, missing auth checks, perf hotspots).

### 6.2 How workers submit proposals

Workers already have an HTTP client to talk to MoonMind (queue claim/heartbeat/etc.) in `moonmind/agents/codex_worker/worker.py`. Extend that client (or add `ProposalApiClient`) with:

* `create_proposal(payload: TaskProposalCreateRequest) -> ProposalModel`
* Automatic inclusion of worker metadata (`proposed_by_worker_id`, origin job id, branch, publish artifact links).
* Backoff/retry identical to queue job submit for transient failures (HTTP 5xx, connection issues).

### 6.3 Proposal payload generation guidelines

To ensure “promote → task” works immediately:

* Default proposal repository to the current job’s repo (from canonical payload `repository`).
* If the current job produced a branch/PR, set:
  * `task.git.startingBranch = <branch>`
  * `task.git.newBranch = null` (so follow-up continues on same branch when non-default)
* Keep publish mode conservative (`branch` by default; `none` for experiments; `pr` if it is review-ready).
* Provide succinct instructions (<= 300 characters) so the dashboard preview remains readable.

### 6.4 Failure reporting

* Worker retries proposal submission up to 3 times before logging a warning.
* Failed submissions surface in worker telemetry to avoid silent drops.
* Workers include proposal id (if created) in final job logs so humans can link back quickly.

---

## 7. Task Dashboard UX

MoonMind’s dashboard shell + runtime config is already designed to add sources cleanly, but server routes currently only allow `/tasks/queue/*` and `/tasks/orchestrator/*`.

### 7.1 New routes

* `/tasks/proposals` — list view (filterable).
* `/tasks/proposals/{proposalId}` — detail view.

Update the router allowlist to include these new paths and ensure deep links persist across deployments.

### 7.2 Runtime config additions

Extend `build_runtime_config()` to add:

```json
"sources": {
  "proposals": {
    "list": "/api/proposals",
    "detail": "/api/proposals/{id}",
    "promote": "/api/proposals/{id}/promote",
    "dismiss": "/api/proposals/{id}/dismiss"
  }
}
```

### 7.3 UI behavior

In `dashboard.js` (client-side router):

**Proposals list page**

* Fetch `GET /api/proposals?status=open&limit=200` (plus repo/category filters when set).
* Render a table: short id, category, title, repository (derived from payload), origin link, created time, status.
* Provide quick actions per row:
  * “Promote to Task” (calls promote endpoint; redirect to `/tasks/queue/{jobId}`)
  * “Dismiss” (updates row inline).
  * Repo filter chips once §11 decision is implemented.

**Proposal detail page**

* Show title, summary, category, tags.
* Show origin references (link to `/tasks/queue/{originId}` when source is queue, orchestrator run view otherwise).
* Include a “Task Preview” card derived from `taskCreateRequest.payload`: repo, runtime, skill, publish mode, starting/new branch, instructions excerpt.
* Primary CTA: **Promote to Task** (plus Dismiss secondary CTA).
* All proposal text is treated as untrusted user content and must be escaped (dashboard already uses `escapeHtml()` patterns).

---

## 8. Security, Policy, and Abuse Prevention

1. **Secret redaction:** Scrub proposal fields server-side using the existing `SecretRedactor` utilities shared with queue submission paths.
2. **Auth boundary:** Proposal creation requires worker tokens with `proposals_write` or user auth; promotion/dismiss/list remain user-auth only.
3. **Task contract validation:** Reuse canonical queue validation helpers so promotions never fail due to schema issues.
4. **Rate limiting:** Apply per-worker proposal submission rate limits (e.g., 30/min) to avoid spam and protect the DB.
5. **XSS:** UI must escape all proposal content; never render raw HTML.
6. **Audit logging:** Log create/promote/dismiss events with actor ids for later investigations.

---

## 9. Observability

Add metrics (StatsD or logging-based counters) analogous to existing system telemetry patterns:

* `proposals.created.count` (tags: category, origin_source, repository).
* `proposals.promoted.count` (tags: category, repository).
* `proposals.dismissed.count`.
* `proposals.promote.failed.count` (tags: error_code like invalid payload / unauthorized / queue validation).

Also store basic decision trail on the proposal row (who promoted/dismissed and when) and emit structured logs for dashboard audit components.

---

## 10. Rollout Plan

### Phase 1 (MVP)

* DB: add `task_proposals` table + migration (with capability flag default OFF).
* API: implement create/list/detail/promote/dismiss endpoints and associated authorization checks.
* Worker: add proposal submission helper and behind-a-flag call at publish completion.
* Dashboard: add proposals routes + list/detail + promote CTA.

### Phase 2 (Polish)

* Deduplication key + “similar proposals” (hash on repo + normalized title).
* Optional editing UI (“edit before promote”)—still keep one-click promote as default.
* Proposal “snooze” and “priority triage”.
* Notifications (Slack/webhook) when new proposals land in `security` or `tests` categories.

**Implementation Status (2026-02-18):** Phase 2 is now live. The API stores `dedupKey`/`dedupHash`, exposes `/api/proposals/{id}/priority`, `/snooze`, and `/unsnooze`, and accepts `taskCreateRequestOverride` patches during promotion. The dashboard renders similar proposals, edit-before-promote controls, priority badges, and snooze forms. Notifications dispatch via the configured `TASK_PROPOSALS_NOTIFICATIONS_*` settings and log to `task_proposal_notifications`.

---

## 11. Resolved Policy Knobs

1. **Worker capability requirement:** Yes. Worker-submitted proposals must present a token with `capabilities` containing `proposals_write`. Ship with capability disabled by default; explicitly grant it to Codex workers once server + DB migrations are live. This keeps proposal creation off for experimental workers and provides an audit trail for abuse.
2. **Per-repo filtering in UI:** Yes. Crowd feedback showed reviewers typically triage per repository. Add `repository` query parameter + UI filter chips defaulting to `all`, with the list page remembering the last repo filter in `localStorage`.
3. **Promotion behavior:** Promotion continues to “enqueue immediately” (creates a standard queue job that enters `queued` state). Draft tasks introduce new lifecycle complexity and overlap with existing `accepted`/`rejected` states; keeping queue semantics unchanged ensures proposals remain a thin funnel over the Agent Queue.

---

## 12. Implementation Checklist

* [ ] Land migration creating `task_proposals` table + indexes.
* [ ] Update API schemas (`api_service/schemas/*.py`) and OpenAPI docs.
* [ ] Add worker client + feature flag `ENABLE_TASK_PROPOSALS`.
* [ ] Extend dashboard runtime config + router + new views in `dashboard.js`.
* [ ] Add monitoring dashboards/alerts for proposal metrics.
* [ ] Document reviewer workflow in `docs/TaskUiArchitecture.md` once deployed.
