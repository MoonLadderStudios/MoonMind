name: PR Manager

on:
  workflow_run:
    workflows:
      # This repo uses "Run Pytest Unit Tests" instead of the older
      # "Build Project and Run Tests" pipeline name.
      - Build Project and Run Tests
      - Run Pytest Unit Tests
    types: [completed]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

permissions:
  pull-requests: write
  issues: write
  checks: read
  contents: write

concurrency:
  group: >-
    pr-manager-${{
      github.event.pull_request.number ||
      github.event.issue.number ||
      (github.event.workflow_run && github.event.workflow_run.pull_requests &&
        github.event.workflow_run.pull_requests[0] &&
        github.event.workflow_run.pull_requests[0].number) ||
      github.event.workflow_run.head_sha ||
      github.event.pull_request.head.sha ||
      'global'
    }}
  cancel-in-progress: true

jobs:
  check-and-comment:
    # Suppress human @codex pings, but allow Codex-bot-initiated events
    # Also allow google-labs-jules to trigger events
    if: >
      !(
        (!contains(github.actor || '', 'chatgpt-codex-connector') && !contains(github.actor || '', 'google-labs-jules')) &&
        (
          (github.event_name == 'issue_comment' &&
           contains(github.event.comment.body || '', '@codex')) ||
          (github.event_name == 'pull_request_review_comment' &&
           contains(github.event.comment.body || '', '@codex')) ||
          (github.event_name == 'pull_request_review' &&
           contains(github.event.review.body || '', '@codex'))
        )
      )
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate PR and decide action
        id: eval
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AGENT_TOKEN || github.token }}
          script: |
            let pr_number = context.payload.pull_request?.number || context.payload.issue?.number;
            const workflowRun = context.eventName === 'workflow_run'
              ? context.payload.workflow_run
              : null;

            // Both the legacy and current CI workflows are treated as "build/test" gates
            const BUILD_WORKFLOW_NAMES = [
              'Build Project and Run Tests',
              'Run Pytest Unit Tests',
            ];

            const isSuccessfulBuildWorkflowRun =
              Boolean(workflowRun) &&
              BUILD_WORKFLOW_NAMES.includes(workflowRun.name || '') &&
              (workflowRun.conclusion || '').toLowerCase() === 'success';

            core.setOutput('ready', 'false');
            core.setOutput('pr', pr_number ? String(pr_number) : '');

            const eventName = context.eventName || '';
            const triggeringCommentBody = context.payload.comment?.body || context.payload.review?.body || '';
            const triggeringActor = context.actor?.toLowerCase?.() || '';
            const workflowName = context.workflow || '';

            // Suppress only human @codex mentions; allow Codex-bot
            if (['issue_comment', 'pull_request_review_comment', 'pull_request_review'].includes(eventName)) {
              const codexMentionPattern = /@\S*codex\S*/i;
              const actorIsCodex = triggeringActor.includes('chatgpt-codex-connector') || triggeringActor.includes('google-labs-jules');
              if (!actorIsCodex && codexMentionPattern.test(triggeringCommentBody)) {
                console.log('Detected direct @ mention of Codex in comment event. Skipping to avoid duplicate fix requests.');
                return;
              }
            }

            if (workflowRun) {
              const associatedPRs = Array.isArray(workflowRun.pull_requests)
                ? workflowRun.pull_requests
                : [];

              if (associatedPRs.length === 0) {
                console.log('Workflow run is not associated with a pull request. Skipping.');
                return;
              }

              if (associatedPRs.length > 1) {
                console.log(`Workflow run references multiple PRs (${associatedPRs.length}). Using the first.`);
              }

              pr_number = associatedPRs[0]?.number;
            }

            console.log(`Triggered by actor: ${triggeringActor || 'unknown'}`);

            const triggeredByCodexBot = triggeringActor.includes('chatgpt-codex-connector');
            if (triggeredByCodexBot) {
              console.log('Event was emitted by Codex bot. Continuing so reviewer findings can be processed.');
            }

            if (!pr_number) {
              console.log('Not a PR event, skipping');
              return;
            }

            if (context.payload.issue && !context.payload.issue.pull_request) {
              console.log('Issue comment not associated with a PR, skipping');
              return;
            }

            console.log(`Event: ${context.eventName} (action: ${context.payload.action || 'n/a'})`);
            console.log(`Processing PR #${pr_number}`);

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number
            });

            console.log(`PR: ${pr.title}`);
            console.log(`Head SHA: ${pr.head.sha}`);
            console.log(`PR created at: ${pr.created_at}`);

            // Skip when PR is not open
            if ((pr.state || '').toLowerCase() !== 'open') {
              console.log(`PR is not open (state: ${pr.state}). Skipping auto-merge logic.`);
              return;
            }

            if (workflowRun) {
              const runHeadSha = workflowRun.head_sha || '';
              console.log(`Workflow run head SHA: ${runHeadSha || 'unknown'}`);

              if (runHeadSha && runHeadSha !== pr.head.sha) {
                console.log('Workflow run head SHA does not match current PR head. Run is stale, skipping.');
                return;
              }

              const runConclusion = workflowRun.conclusion || 'unknown';
              console.log(`Workflow run conclusion: ${runConclusion}`);

              if (!['success', 'failure', 'neutral', 'cancelled', 'timed_out', 'action_required', 'skipped'].includes(runConclusion)) {
                console.log('Workflow run is not in a final state we handle. Skipping.');
                return;
              }
            }

            console.log(`Build workflow success gate (this run): ${isSuccessfulBuildWorkflowRun}`);

            // Get commits to find the latest commit timestamp
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              per_page: 100
            });

            console.log(`Total commits: ${commits.length}`);

            // If there's more than one commit, only consider comments after the latest commit
            let commentCutoffDate = new Date(pr.created_at);
            if (commits.length > 1) {
              const latestCommit = commits[commits.length - 1];
              commentCutoffDate = new Date(latestCommit.commit.committer.date);
              console.log(`Multiple commits detected. Only considering comments after: ${commentCutoffDate.toISOString()}`);
            } else {
              console.log('Single commit. Considering all comments since PR creation.');
            }

            // Check if another instance of THIS workflow is already running for this PR
            const listWorkflowRunsParams = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              status: 'in_progress',
              per_page: 100
            };
            if (context.eventName && context.eventName !== 'workflow_run') {
              listWorkflowRunsParams.event = context.eventName;
            }

            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo(listWorkflowRunsParams);

            // Filter to this same workflow name to avoid unrelated CI causing early exit
            const sameWorkflowRuns = (workflowRuns.workflow_runs || []).filter(run => (run.name || '') === workflowName);

            const otherRunsForThisPR = sameWorkflowRuns.filter(run => {
              const runPR = run.pull_requests?.find(p => p.number === pr_number);
              return runPR && run.id !== context.runId;
            });

            if (otherRunsForThisPR.length > 0) {
              console.log(`Found ${otherRunsForThisPR.length} other active run(s) of this workflow for this PR. Exiting to avoid duplicates.`);
              return;
            }

            // Retry logic: wait for eyes reactions to clear and checks to complete
            const MAX_RETRIES = 10;
            const RETRY_DELAY_MS = 60000; // 1 minute base delay
            let retryCount = 0;
            let shouldWait = true;
            let checkRunsExcludingSelf = [];

            const waitWithJitter = async (baseDelayMs) => {
              const jitterMs = (Math.random() * 2 - 1) * 15000; // ±15s jitter
              const delayMs = Math.max(5000, Math.round(baseDelayMs + jitterMs));
              console.log(`Waiting ${Math.round(delayMs / 1000)} seconds before re-checking...`);
              await new Promise(resolve => setTimeout(resolve, delayMs));
            };

            while (shouldWait && retryCount < MAX_RETRIES) {
              // Check for "eyes" reactions on the PR (recent-only window)
              const { data: reactions } = await github.rest.reactions.listForIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number
              });

              const cutoffMillis = Math.max(commentCutoffDate.getTime(), Date.now() - 2 * 60 * 60 * 1000);
              const hasEyesReaction = reactions.some(r =>
                r.content === 'eyes' &&
                new Date(r.created_at).getTime() >= cutoffMillis
              );

              if (hasEyesReaction) {
                console.log(`[Attempt ${retryCount + 1}/${MAX_RETRIES}] PR has "eyes" reactions - someone is reviewing.`);
                if (retryCount < MAX_RETRIES - 1) {
                  retryCount++;
                  await waitWithJitter(RETRY_DELAY_MS);
                  continue;
                } else {
                  console.log('Max retries reached. Exiting.');
                  return;
                }
              }

              console.log('No "eyes" reactions found. Checking GitHub Actions status...');

              // Check if all checks are completed, ignoring this workflow's own run
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
                per_page: 100
              });

              const currentRunId = String(context.runId || process.env.GITHUB_RUN_ID || '');
              const currentRunFragment = currentRunId ? `/runs/${currentRunId}` : null;
              checkRunsExcludingSelf = checkRuns.check_runs.filter(run => {
                const runName = run.name || '';
                const isCurrentWorkflow = runName === workflowName || runName.startsWith(`${workflowName} /`);
                const detailsUrl = run.details_url || '';
                const externalId = run.external_id || '';

                const matchesCurrentRun = Boolean(currentRunId) && (
                  (detailsUrl && currentRunFragment && detailsUrl.includes(currentRunFragment)) ||
                  externalId === currentRunId
                );

                const shouldExclude = matchesCurrentRun ||
                  (isCurrentWorkflow && run.status !== 'completed' && Boolean(currentRunId));

                if (shouldExclude) {
                  console.log(`Excluding current workflow check run: ${runName} (id ${run.id})`);
                }

                return !shouldExclude;
              });

              console.log(`Total check runs: ${checkRuns.check_runs.length}`);
              console.log(`Check runs (excluding current workflow): ${checkRunsExcludingSelf.length}`);

              const allChecksCompleted = checkRunsExcludingSelf.every(
                run => run.status === 'completed'
              );

              if (!allChecksCompleted) {
                console.log(`[Attempt ${retryCount + 1}/${MAX_RETRIES}] Not all checks are completed yet.`);
                if (retryCount < MAX_RETRIES - 1) {
                  retryCount++;
                  await waitWithJitter(RETRY_DELAY_MS);
                  continue;
                } else {
                  console.log('Max retries reached. Exiting.');
                  return;
                }
              }

              // Both conditions met, exit retry loop
              shouldWait = false;
              console.log('All checks completed and no eyes reactions. Continuing...');
            }

            console.log('Checking check conclusions...');

            // Treat "skipped" and "cancelled" as non-failures
            const failureConclusions = new Set(['failure', 'timed_out', 'action_required']);
            const hasFailures = checkRunsExcludingSelf.some(run => {
              const conclusion = run.conclusion;
              if (conclusion === 'cancelled') {
                console.log(`Ignoring cancelled check run: ${run.name} (id ${run.id}).`);
                return false;
              }
              return failureConclusions.has(conclusion);
            });

            console.log(`Has failures: ${hasFailures}`);

            // Identify build / test check run(s) for auto-review and auto-merge gating
            const buildWorkflowPrefixes = BUILD_WORKFLOW_NAMES.map(
              name => `${name} /`.toLowerCase()
            );
            const buildCheckExactNames = new Set([
              'test',
              'test (pull_request)',
              'run pytest unit tests',
              'run pytest unit tests / test',
              'run pytest unit tests / test (pull_request)',
            ]);

            const matchesBuildCheckName = (rawName) => {
              const name = (rawName || '').trim();
              if (!name) {
                return false;
              }
              const normalizedName = name.toLowerCase();
              if (buildWorkflowPrefixes.some(prefix => normalizedName.startsWith(prefix))) {
                return true;
              }
              return buildCheckExactNames.has(normalizedName);
            };

            const buildCheckCandidates = checkRunsExcludingSelf.filter(run =>
              matchesBuildCheckName(run.name)
            );

            let buildCheck = null;
            if (buildCheckCandidates.length > 0) {
              // Prefer a successful build/test check if available
              buildCheck = buildCheckCandidates.find(run => run.conclusion === 'success') || buildCheckCandidates[0];
            }

            if (!buildCheck && buildCheckCandidates.length > 0) {
              const availableNames = buildCheckCandidates.map(run => run.name || '(unnamed)').join(', ');
              console.log(`No successful build/test check found. Candidates: [${availableNames}]`);
            }

            let buildCheckSucceeded = Boolean(buildCheck) && buildCheck.conclusion === 'success';
            if (buildCheck) {
              console.log(`Evaluated build/test check '${buildCheck.name}' (conclusion: ${buildCheck.conclusion})`);
            } else if (isSuccessfulBuildWorkflowRun) {
              console.log('No matching build/test check run was returned, but the triggering workflow_run succeeded. Treating this as a successful build/test gate.');
              buildCheckSucceeded = true;
            }
            console.log(`Build/test check succeeded: ${buildCheckSucceeded}`);

            // Get all PR review comments
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              per_page: 100
            });

            // Get review bodies (not just inline comments) so P0/P1 findings in full reviews are detected
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              per_page: 100
            });

            // Get all issue comments
            const { data: issueComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              per_page: 100
            });

            const headShaLower = (pr.head.sha || '').toLowerCase();
            const reviewCommentsOnHead = reviewComments.filter(comment => {
              const commitIdLower = (comment.commit_id || '').toLowerCase();
              return commitIdLower && commitIdLower === headShaLower;
            });

            // Normalize review bodies to comment-like objects for downstream filtering
            const reviewBodies = reviews
              .filter(review => (review.body || '').trim())
              .map(review => {
                const createdAt =
                  review.submitted_at ||
                  review.submittedAt ||
                  review.created_at ||
                  review.createdAt ||
                  review.updated_at ||
                  review.updatedAt ||
                  null;
                return {
                  ...review,
                  created_at: createdAt,
                  body: review.body,
                };
              })
              .filter(review => review.created_at);

            console.log(`Review bodies collected: ${reviewBodies.length}`);

            const allComments = [...reviewCommentsOnHead, ...issueComments, ...reviewBodies];

            console.log(`Total comments (all time): ${allComments.length}`);

            // Filter comments to only those after the cutoff date
            const commentsAfterCutoff = allComments.filter(comment => {
              const commentDate = new Date(comment.created_at);
              return commentDate > commentCutoffDate;
            });

            const relevantComments = commentsAfterCutoff.slice();

            console.log(`Comments after cutoff date: ${relevantComments.length}`);

            const extractGeminiSeverity = (body) => {
              if (!body) {
                return null;
              }

              const patterns = [
                /(?:^|\n)\s*(?:[-*+]\s*)?\*{0,2}(?:priority|severity)\*{0,2}\s*[:\-–—]\s*(critical|high|medium|low)\b/i,
                /(?:^|\n)\s*(critical|high|medium|low)\s*(?:\n|$)/i,
              ];

              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match) {
                  return match[1].toLowerCase();
                }
              }

              return null;
            };

            const hasCodexHighPriorityFinding = (body) => {
              if (!body) return false;
              const patterns = [
                /P0\s+Badge/i,
                /P1\s+Badge/i,
                /Priority\s*[:\-–—]\s*(?:P0|P1)/i,
                /Severity\s*[:\-–—]\s*(?:P0|P1)/i,
              ];
              return patterns.some(pattern => pattern.test(body));
            };

            const geminiStatusPatterns = [
              /unable to generate (?:a\s+)?summary/i,
              /unable to complete (?:the\s+)?review/i,
              /unable to review(?:\s+this\s+(?:pull\s+request|pr))?/i,
              /could not review/i,
              /cannot review/i,
              /review (?:results )?are not available/i,
              /review is (?:temporarily\s+)?unavailable/i,
              /analysis is not available/i,
              /not (?:being\s+)?currently\s+supported/i,
            ];

            const isGeminiStatusOnlyComment = (body) => {
              if (!body) {
                return false;
              }
              return geminiStatusPatterns.some(pattern => pattern.test(body));
            };

            const isGeminiComment = (comment) => {
              const userLogin = comment.user?.login?.toLowerCase() || '';
              const body = comment.body || '';
              const normalizedBody = body.toLowerCase();

              const isGeminiUser =
                userLogin.includes('gemini') ||
                userLogin === 'gemini-code-assist';

              if (!isGeminiUser) {
                return false;
              }

              if (isGeminiStatusOnlyComment(normalizedBody)) {
                console.log('Ignoring Gemini status-only message that is not a review.');
                return false;
              }

              return true;
            };

            const isCodexComment = (comment) => {
              const userLogin = comment.user?.login?.toLowerCase() || '';
              const body = comment.body || '';
              const actorIsCodex = userLogin.includes('codex') ||
                userLogin === 'chatgpt-codex-connector';
              const hasCodexMarker = body.includes('Codex Review') || body.includes('<!-- codex:');

              // Treat any comment from the Codex bot as Codex, even if it is an inline review without the heading.
              return actorIsCodex || hasCodexMarker;
            };

            // Check for Gemini Code Assist comments (High or Critical)
            const isHighPriorityGeminiReview = (comment) => {
              if (!isGeminiComment(comment)) return false;
              const severity = extractGeminiSeverity(comment.body || '');
              return severity === 'high' || severity === 'critical';
            };

            const isHighPriorityCodexReview = (comment) => {
              if (!isCodexComment(comment)) return false;
              return hasCodexHighPriorityFinding(comment.body || '');
            };

            const geminiComments = relevantComments.filter(isHighPriorityGeminiReview);

            console.log(`Gemini High/Critical comments: ${geminiComments.length}`);

            const codexHighPriorityComments = relevantComments.filter(isHighPriorityCodexReview);

            console.log(`Codex high-priority (P0/P1) comments: ${codexHighPriorityComments.length}`);

            const hasBlockingReviewCommentsInRelevantWindow =
              geminiComments.length > 0 || codexHighPriorityComments.length > 0;
            console.log(`Has blocking review comments in relevant window: ${hasBlockingReviewCommentsInRelevantWindow}`);

            const allGeminiHighPriorityComments = allComments.filter(isHighPriorityGeminiReview);
            const allCodexHighPriorityComments = allComments.filter(isHighPriorityCodexReview);
            const hasHistoricalBlockingReviewComments =
              allGeminiHighPriorityComments.length > 0 || allCodexHighPriorityComments.length > 0;
            console.log(`Historical blocking review comments detected: ${hasHistoricalBlockingReviewComments}`);

            // Detect whether a Codex review has already been requested since the latest commit
            const reviewRequestCommentsSinceLastCommit = issueComments.filter(comment => {
              const createdAt = new Date(comment.created_at);
              if (createdAt <= commentCutoffDate) {
                return false;
              }
              const body = (comment.body || '').toLowerCase();
              return body.includes('@codex review');
            });

            const hasReviewRequestSinceLastCommit = reviewRequestCommentsSinceLastCommit.length > 0;
            console.log(`Codex review requests since last commit: ${reviewRequestCommentsSinceLastCommit.length}`);

            // Detect whether any review (Gemini or Codex) has occurred since the last commit
            const anyGeminiReviewSinceLastCommit = commentsAfterCutoff.some(comment => isGeminiComment(comment));
            const anyCodexReviewSinceLastCommit = commentsAfterCutoff.some(comment => isCodexComment(comment));
            const hasAnyReviewSinceLastCommit =
              anyGeminiReviewSinceLastCommit ||
              anyCodexReviewSinceLastCommit;

            const hasUnresolvedBlockingReviewComments = hasBlockingReviewCommentsInRelevantWindow;
            const noBlockingReviewIssues = !hasUnresolvedBlockingReviewComments;
            // Track whether *any* review activity has ever occurred on the PR so we
            // never auto-merge something that has not been reviewed at least once.
            const hasAnyReviewEver = allComments.some(comment =>
              isGeminiComment(comment) || isCodexComment(comment)
            );
            const needsInitialReview = !hasAnyReviewEver;
            const reviewCompletedNoIssues =
              !needsInitialReview &&
              noBlockingReviewIssues &&
              (hasAnyReviewSinceLastCommit || hasAnyReviewEver);

            console.log(`Any review since last commit: ${hasAnyReviewSinceLastCommit}`);
            console.log(`Blocking review comments currently detected: ${hasBlockingReviewCommentsInRelevantWindow}`);
            console.log(`Unresolved blocking review comments (after historical fallback): ${hasUnresolvedBlockingReviewComments}`);
            console.log(`No blocking review issues detected: ${noBlockingReviewIssues}`);
            console.log(`Any historical review comments detected: ${hasAnyReviewEver}`);
            console.log(`Review completed with no blocking issues: ${reviewCompletedNoIssues}`);
            if (needsInitialReview) {
              console.log('Review gate blocking: no Codex/Gemini review has ever occurred on this PR.');
            }
            if (!reviewCompletedNoIssues) {
              if (!noBlockingReviewIssues) {
                console.log('Review gate blocking: high-priority review issues remain unresolved.');
              } else if (needsInitialReview) {
                console.log('Review gate blocking: no review activity has occurred on this PR yet.');
              }
            }

            // Determine build / review-trigger conditions
            const buildFailed = hasFailures;
            const buildSucceededForThisRun = isSuccessfulBuildWorkflowRun && buildCheckSucceeded;

            const shouldRequestReviewFromBuild =
              buildSucceededForThisRun &&
              !buildFailed &&
              !hasUnresolvedBlockingReviewComments &&
              !hasReviewRequestSinceLastCommit &&
              needsInitialReview;

            console.log(`Build succeeded for this workflow_run: ${buildSucceededForThisRun}`);
            console.log(`Should request Codex review from build: ${shouldRequestReviewFromBuild}`);

            // Determine what action to take
            let commentBody = null;
            const allowSelfTriggeredBlockingHandling =
              triggeredByCodexBot && hasUnresolvedBlockingReviewComments;

            if (triggeredByCodexBot && !allowSelfTriggeredBlockingHandling) {
              console.log('Blocking command generation because the event was initiated by the Codex bot and no blocking P0/P1 findings are present.');
            } else if (hasFailures && hasUnresolvedBlockingReviewComments) {
              commentBody = '@codex fix comments and fix build failures';
            } else if (hasFailures) {
              commentBody = '@codex fix build failures';
            } else if (hasUnresolvedBlockingReviewComments) {
              commentBody = '@codex fix comments';
            } else if (shouldRequestReviewFromBuild) {
              commentBody = '@codex review\n@gemini-code-assist review';
            }

            if (commentBody) {
              const normalizedCommentBody = commentBody.trim();
              const normalizedCommentBodyLower = normalizedCommentBody.toLowerCase();
              const headSha = pr.head.sha;

              let purpose = 'general';
              if (normalizedCommentBodyLower.includes('fix comments and fix build failures')) {
                purpose = 'comments-and-build';
              } else if (normalizedCommentBodyLower.includes('fix build failures')) {
                purpose = 'build-fix';
              } else if (normalizedCommentBodyLower.includes('fix comments')) {
                purpose = 'comment-fix';
              } else if (normalizedCommentBodyLower.includes('@codex review')) {
                purpose = 'review';
              }

              const marker = `<!-- codex:${purpose} sha=${headSha} -->`;
              const shaMarkerRegex = new RegExp(`<!--\\s*codex:[^>]*\\bsha=${headSha}\\b`, 'i');
              const markerStripRegex = /<!--\s*codex:[^>]*sha=[^>]+-->/i;

              const isCodexBot = (comment) => {
                const login = comment.user?.login || '';
                const body = comment.body || '';
                const isBotUser = comment.user?.type === 'Bot' && /chatgpt-codex-connector/i.test(login);
                const hasMarker = body.includes('<!-- codex:');
                return isBotUser || hasMarker;
              };

              // Try to update an existing comment for the same SHA, rather than posting anew
              const existingCommentForSha = issueComments.find(comment => {
                if (!isCodexBot(comment)) return false;
                return shaMarkerRegex.test(comment.body || '');
              });

              if (existingCommentForSha) {
                const existingBody = existingCommentForSha.body || '';
                const existingMessage = existingBody.replace(markerStripRegex, '').trim();
                const alreadyMatches = existingMessage.toLowerCase() === normalizedCommentBodyLower;

                if (alreadyMatches) {
                  console.log(`Existing Codex comment already matches desired message for ${headSha}. Skipping.`);
                  return;
                }

                const updatedBody = [marker, normalizedCommentBody].join('\n');
                console.log(`Updating existing Codex comment ${existingCommentForSha.id} for SHA ${headSha}.`);
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingCommentForSha.id,
                  body: updatedBody
                });
                console.log('Codex comment updated successfully.');
                return;
              }

            const hasRecentFixCommand = commentsAfterCutoff.some(comment => {
              const body = (comment.body || '').toLowerCase();
              return /@codex\s+fix\b/.test(body);
            });

            // Only block new fix commands if one already exists; allow @codex review
            if (hasRecentFixCommand && normalizedCommentBodyLower.startsWith('@codex fix')) {
              console.log('A @codex fix command already exists since the latest commit. Skipping new fix request.');
              return;
            }

            // Additional check: Prevent duplicate fix commands for the same exact issue on the same commit
            const exactMatchInRecentComments = commentsAfterCutoff.some(comment => {
              const body = (comment.body || '').toLowerCase();
              const cleanBody = body.replace(/<!--[^>]*-->/g, '').trim();
              return cleanBody === normalizedCommentBodyLower;
            });

            if (exactMatchInRecentComments) {
              console.log(`Exact match found for "${normalizedCommentBody}" since latest commit. Skipping duplicate.`);
              return;
            }

              const RATE_LIMIT_WINDOW_MS = 5 * 60 * 1000;
              const cutoff = Date.now() - RATE_LIMIT_WINDOW_MS;

              const recentBotInvocations = issueComments.filter(comment => {
                if (!isCodexBot(comment)) {
                  return false;
                }
                const createdAt = new Date(comment.created_at).getTime();
                if (createdAt < cutoff) {
                  return false;
                }
                const body = comment.body || '';
                return body.includes(`<!-- codex:${purpose} `);
              });

              if (recentBotInvocations.length > 0) {
                console.log(`Recent Codex bot activity detected (<5m) for purpose '${purpose}'. Skipping to avoid spam.`);
                return;
              }

              const { data: latestIssueComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                per_page: 50
              });

              const duplicateOnLastPage = latestIssueComments.some(comment => (comment.body || '').includes(marker));
              if (duplicateOnLastPage) {
                console.log('A matching Codex comment appeared while preparing to post. Skipping to avoid duplicates.');
                return;
              }

              const body = [marker, normalizedCommentBody].join('\n');

              console.log(`Posting comment for purpose '${purpose}': ${normalizedCommentBody}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body
              });
              console.log('Comment posted successfully!');
            } else {
              console.log('No action needed. PR looks good!');
            }

            const readyToMerge = buildCheckSucceeded &&
              !hasFailures &&
              reviewCompletedNoIssues &&
              !pr.draft &&
              !shouldRequestReviewFromBuild;

            core.setOutput('ready', String(readyToMerge));
            core.setOutput('pr', String(pr_number));
            console.log(`Ready for auto-merge: ${readyToMerge}`);

      - name: Enable native auto-merge
        if: steps.eval.outputs.ready == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.PR_AGENT_TOKEN || github.token }}
          pull-request-number: ${{ steps.eval.outputs.pr }}
          merge-method: merge
