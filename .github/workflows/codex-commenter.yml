name: Codex Commenter

on:
  workflow_run:
    workflows:
      # This repo uses "Run Pytest Unit Tests" instead of the older
      # "Build Project and Run Tests" pipeline name.
      - Build Project and Run Tests
      - Run Pytest Unit Tests
    types: [completed]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

permissions:
  pull-requests: write
  issues: write
  checks: read
  contents: write

concurrency:
  group: >-
    codex-commenter-${{
      github.event.pull_request.number ||
      github.event.issue.number ||
      (github.event.workflow_run && github.event.workflow_run.pull_requests &&
        github.event.workflow_run.pull_requests[0] &&
        github.event.workflow_run.pull_requests[0].number) ||
      github.event.workflow_run.head_sha ||
      github.event.pull_request.head.sha ||
      github.event.workflow_run.id ||
      github.run_id
    }}
  cancel-in-progress: true

jobs:
  check-and-comment:
    # Suppress human @codex pings, but allow Codex-bot-initiated events
    if: >
      !(
        !contains(github.actor || '', 'chatgpt-codex-connector') &&
        (
          (github.event_name == 'issue_comment' &&
           contains(github.event.comment.body || '', '@codex')) ||
          (github.event_name == 'pull_request_review_comment' &&
           contains(github.event.comment.body || '', '@codex')) ||
          (github.event_name == 'pull_request_review' &&
           contains(github.event.review.body || '', '@codex'))
        )
      )
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate PR and decide action
        id: eval
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AGENT_TOKEN || github.token }}
          script: |
            let pr_number = context.payload.pull_request?.number || context.payload.issue?.number;
            const workflowRun = context.eventName === 'workflow_run'
              ? context.payload.workflow_run
              : null;

            core.setOutput('ready', 'false');
            core.setOutput('pr', pr_number ? String(pr_number) : '');

            const eventName = context.eventName || '';
            const triggeringCommentBody = context.payload.comment?.body || context.payload.review?.body || '';
            const triggeringActor = context.actor?.toLowerCase?.() || '';
            const workflowName = context.workflow || '';

            // Suppress only human @codex mentions; allow Codex-bot
            if (['issue_comment', 'pull_request_review_comment', 'pull_request_review'].includes(eventName)) {
              const codexMentionPattern = /@\S*codex\S*/i;
              const actorIsCodex = triggeringActor.includes('chatgpt-codex-connector');
              if (!actorIsCodex && codexMentionPattern.test(triggeringCommentBody)) {
                console.log('Detected direct @ mention of Codex in comment event. Skipping to avoid duplicate fix requests.');
                return;
              }
            }

            if (workflowRun) {
              const associatedPRs = Array.isArray(workflowRun.pull_requests)
                ? workflowRun.pull_requests
                : [];

              if (associatedPRs.length === 0) {
                console.log('Workflow run is not associated with a pull request. Skipping.');
                return;
              }

              if (associatedPRs.length > 1) {
                console.log(`Workflow run references multiple PRs (${associatedPRs.length}). Using the first.`);
              }

              pr_number = associatedPRs[0]?.number;
            }

            console.log(`Triggered by actor: ${triggeringActor || 'unknown'}`);

            const triggeredByCodexBot = triggeringActor.includes('chatgpt-codex-connector');
            if (triggeredByCodexBot) {
              console.log('Event was emitted by Codex bot. Continuing so reviewer findings can be processed.');
            }

            if (!pr_number) {
              console.log('Not a PR event, skipping');
              return;
            }

            if (context.payload.issue && !context.payload.issue.pull_request) {
              console.log('Issue comment not associated with a PR, skipping');
              return;
            }

            console.log(`Event: ${context.eventName} (action: ${context.payload.action || 'n/a'})`);
            console.log(`Processing PR #${pr_number}`);

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number
            });

            console.log(`PR: ${pr.title}`);
            console.log(`Head SHA: ${pr.head.sha}`);
            console.log(`PR created at: ${pr.created_at}`);

            // Skip when PR is not open
            if ((pr.state || '').toLowerCase() !== 'open') {
              console.log(`PR is not open (state: ${pr.state}). Skipping auto-merge logic.`);
              return;
            }

            if (workflowRun) {
              const runHeadSha = workflowRun.head_sha || '';
              console.log(`Workflow run head SHA: ${runHeadSha || 'unknown'}`);

              if (runHeadSha && runHeadSha !== pr.head.sha) {
                console.log('Workflow run head SHA does not match current PR head. Run is stale, skipping.');
                return;
              }

              const runConclusion = workflowRun.conclusion || 'unknown';
              console.log(`Workflow run conclusion: ${runConclusion}`);

              if (!['success', 'failure', 'neutral', 'cancelled', 'timed_out', 'action_required', 'skipped'].includes(runConclusion)) {
                console.log('Workflow run is not in a final state we handle. Skipping.');
                return;
              }
            }

            // Get commits to find the latest commit timestamp
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              per_page: 100
            });

            console.log(`Total commits: ${commits.length}`);

            // If there's more than one commit, only consider comments after the latest commit
            let commentCutoffDate = new Date(pr.created_at);
            if (commits.length > 1) {
              const latestCommit = commits[commits.length - 1];
              commentCutoffDate = new Date(latestCommit.commit.committer.date);
              console.log(`Multiple commits detected. Only considering comments after: ${commentCutoffDate.toISOString()}`);
            } else {
              console.log(`Single commit. Considering all comments since PR creation.`);
            }

            // Check if another instance of THIS workflow is already running for this PR
            const listWorkflowRunsParams = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              status: 'in_progress',
              per_page: 100
            };
            if (context.eventName && context.eventName !== 'workflow_run') {
              listWorkflowRunsParams.event = context.eventName;
            }

            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo(listWorkflowRunsParams);

            // Filter to this same workflow name to avoid unrelated CI causing early exit
            const sameWorkflowRuns = (workflowRuns.workflow_runs || []).filter(run => (run.name || '') === workflowName);

            const otherRunsForThisPR = sameWorkflowRuns.filter(run => {
              const runPR = run.pull_requests?.find(p => p.number === pr_number);
              return runPR && run.id !== context.runId;
            });

            if (otherRunsForThisPR.length > 0) {
              console.log(`Found ${otherRunsForThisPR.length} other active run(s) of this workflow for this PR. Exiting to avoid duplicates.`);
              return;
            }

            // Retry logic: wait for eyes reactions to clear and checks to complete
            const MAX_RETRIES = 10;
            const RETRY_DELAY_MS = 60000; // 1 minute base delay
            let retryCount = 0;
            let shouldWait = true;
            let checkRunsExcludingSelf = [];

            const waitWithJitter = async (baseDelayMs) => {
              const jitterMs = (Math.random() * 2 - 1) * 15000; // Â±15s jitter
              const delayMs = Math.max(5000, Math.round(baseDelayMs + jitterMs));
              console.log(`Waiting ${Math.round(delayMs / 1000)} seconds before re-checking...`);
              await new Promise(resolve => setTimeout(resolve, delayMs));
            };

            while (shouldWait && retryCount < MAX_RETRIES) {
              // Check for "eyes" reactions on the PR (recent-only window)
              const { data: reactions } = await github.rest.reactions.listForIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number
              });

              const cutoffMillis = Math.max(commentCutoffDate.getTime(), Date.now() - 2 * 60 * 60 * 1000);
              const hasEyesReaction = reactions.some(r =>
                r.content === 'eyes' &&
                new Date(r.created_at).getTime() >= cutoffMillis
              );

              if (hasEyesReaction) {
                console.log(`[Attempt ${retryCount + 1}/${MAX_RETRIES}] PR has "eyes" reactions - someone is reviewing.`);
                if (retryCount < MAX_RETRIES - 1) {
                  retryCount++;
                  await waitWithJitter(RETRY_DELAY_MS);
                  continue;
                } else {
                  console.log('Max retries reached. Exiting.');
                  return;
                }
              }

              console.log('No "eyes" reactions found. Checking GitHub Actions status...');

              // Check if all checks are completed, ignoring this workflow's own run
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
                per_page: 100
              });

              const currentRunId = String(context.runId || process.env.GITHUB_RUN_ID || '');
              const currentRunFragment = currentRunId ? `/runs/${currentRunId}` : null;
              checkRunsExcludingSelf = checkRuns.check_runs.filter(run => {
                const runName = run.name || '';
                const isCurrentWorkflow = runName === workflowName || runName.startsWith(`${workflowName} /`);
                const detailsUrl = run.details_url || '';
                const externalId = run.external_id || '';

                const matchesCurrentRun = Boolean(currentRunId) && (
                  (detailsUrl && currentRunFragment && detailsUrl.includes(currentRunFragment)) ||
                  externalId === currentRunId
                );

                const shouldExclude = matchesCurrentRun ||
                  (isCurrentWorkflow && run.status !== 'completed' && Boolean(currentRunId));

                if (shouldExclude) {
                  console.log(`Excluding current workflow check run: ${runName} (id ${run.id})`);
                }

                return !shouldExclude;
              });

              console.log(`Total check runs: ${checkRuns.check_runs.length}`);
              console.log(`Check runs (excluding current workflow): ${checkRunsExcludingSelf.length}`);

              const allChecksCompleted = checkRunsExcludingSelf.every(
                run => run.status === 'completed'
              );

              if (!allChecksCompleted) {
                console.log(`[Attempt ${retryCount + 1}/${MAX_RETRIES}] Not all checks are completed yet.`);
                if (retryCount < MAX_RETRIES - 1) {
                  retryCount++;
                  await waitWithJitter(RETRY_DELAY_MS);
                  continue;
                } else {
                  console.log('Max retries reached. Exiting.');
                  return;
                }
              }

              // Both conditions met, exit retry loop
              shouldWait = false;
              console.log('All checks completed and no eyes reactions. Continuing...');
            }

            console.log('Checking check conclusions...');

            // Treat "skipped" as non-failure
            const failureConclusions = new Set(['failure', 'timed_out', 'action_required', 'cancelled']);
            const hasFailures = checkRunsExcludingSelf.some(
              run => failureConclusions.has(run.conclusion)
            );

            console.log(`Has failures: ${hasFailures}`);

            // Get all PR review comments
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              per_page: 100
            });

            // Get all issue comments
            const { data: issueComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              per_page: 100
            });

            const allComments = [...reviewComments, ...issueComments];

            console.log(`Total comments (all time): ${allComments.length}`);

            // Filter comments to only those after the cutoff date
            let relevantComments = allComments.filter(comment => {
              const commentDate = new Date(comment.created_at);
              return commentDate > commentCutoffDate;
            });

            console.log(`Comments after cutoff date: ${relevantComments.length}`);

            if (relevantComments.length === 0 && commits.length > 1) {
              console.log('No post-cutoff comments found but multiple commits exist; falling back to all comments.');
              relevantComments = allComments;
            }

            const extractGeminiSeverity = (body) => {
              if (!body) {
                return null;
              }

              const patterns = [
                /(?:^|\n)\s*(?:[-*+]\s*)?\*{0,2}(?:priority|severity)\*{0,2}\s*[:\-â€“â€”]\s*(critical|high|medium|low)\b/i,
                /(?:^|\n)\s*(critical|high|medium|low)\s*(?:\n|$)/i,
              ];

              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match) {
                  return match[1].toLowerCase();
                }
              }

              return null;
            };

            const hasCodexHighPriorityFinding = (body) => {
              if (!body) return false;
              const patterns = [
                /P0\s+Badge/i,
                /P1\s+Badge/i,
                /Priority\s*[:\-â€“â€”]\s*(?:P0|P1)/i,
                /Severity\s*[:\-â€“â€”]\s*(?:P0|P1)/i,
              ];
              return patterns.some(pattern => pattern.test(body));
            };

            // Check for Gemini Code Assist comments (High or Critical)
            const geminiComments = relevantComments.filter(comment => {
              const userLogin = comment.user?.login?.toLowerCase() || '';
              const body = comment.body || '';
              const isGemini = userLogin.includes('gemini') ||
                               body.includes('Gemini Code Assist') ||
                               userLogin === 'gemini-code-assist';
              if (!isGemini) return false;
              const severity = extractGeminiSeverity(body);
              return severity === 'high' || severity === 'critical';
            });

            console.log(`Gemini High/Critical comments: ${geminiComments.length}`);

            // Check for Codex Review comments (only P0/P1 block/trigger)
            const codexComments = relevantComments.filter(comment => {
              const userLogin = comment.user?.login?.toLowerCase() || '';
              const body = comment.body || '';
              const isCodex = userLogin.includes('codex') ||
                              userLogin === 'chatgpt-codex-connector' ||
                              body.includes('Codex Review') ||
                              body.includes('ðŸ’¡ Codex Review');
              if (!isCodex) return false;
              // Exclude explicit "no issues" summaries
              const isNoIssues = body.includes("Codex Review: Didn't find any major issues.") ||
                                 body.includes("Didn't find any major issues");
              if (isNoIssues) return false;
              return true;
            });

            const codexHighPriorityComments = codexComments.filter(comment =>
              hasCodexHighPriorityFinding(comment.body || '')
            );

            console.log(`Codex high-priority (P0/P1) comments: ${codexHighPriorityComments.length}`);

            const hasReviewComments = geminiComments.length > 0 || codexHighPriorityComments.length > 0;

            // Determine what action to take
            let commentBody = null;

            if (hasFailures && hasReviewComments) {
              commentBody = '@codex fix comments and fix build failures';
            } else if (hasFailures) {
              commentBody = '@codex fix build failures';
            } else if (hasReviewComments) {
              commentBody = '@codex fix comments';
            }

            if (commentBody) {
              const normalizedCommentBody = commentBody.trim();
              const normalizedCommentBodyLower = normalizedCommentBody.toLowerCase();
              const headSha = pr.head.sha;

              let purpose = 'general';
              if (normalizedCommentBodyLower.includes('fix comments and fix build failures')) {
                purpose = 'comments-and-build';
              } else if (normalizedCommentBodyLower.includes('fix build failures')) {
                purpose = 'build-fix';
              } else if (normalizedCommentBodyLower.includes('fix comments')) {
                purpose = 'comment-fix';
              }

              const marker = `<!-- codex:${purpose} sha=${headSha} -->`;
              const shaMarkerRegex = new RegExp(`<!--\\s*codex:[^>]*\\bsha=${headSha}\\b`, 'i');
              const markerStripRegex = /<!--\s*codex:[^>]*sha=[^>]+-->/i;

              const isCodexBot = (comment) => {
                const login = comment.user?.login || '';
                const body = comment.body || '';
                const isBotUser = comment.user?.type === 'Bot' && /chatgpt-codex-connector/i.test(login);
                const hasMarker = body.includes('<!-- codex:');
                return isBotUser || hasMarker;
              };

              // Try to update an existing comment for the same SHA, rather than posting anew
              const existingCommentForSha = issueComments.find(comment => {
                if (!isCodexBot(comment)) return false;
                return shaMarkerRegex.test(comment.body || '');
              });

              if (existingCommentForSha) {
                const existingBody = existingCommentForSha.body || '';
                const existingMessage = existingBody.replace(markerStripRegex, '').trim();
                const alreadyMatches = existingMessage.toLowerCase() === normalizedCommentBodyLower;

                if (alreadyMatches) {
                  console.log(`Existing Codex comment already matches desired message for ${headSha}. Skipping.`);
                  return;
                }

                const updatedBody = [marker, normalizedCommentBody].join('\n');
                console.log(`Updating existing Codex comment ${existingCommentForSha.id} for SHA ${headSha}.`);
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingCommentForSha.id,
                  body: updatedBody
                });
                console.log('Codex comment updated successfully.');
                return;
              }

              const RATE_LIMIT_WINDOW_MS = 5 * 60 * 1000;
              const cutoff = Date.now() - RATE_LIMIT_WINDOW_MS;

              const recentBotInvocations = issueComments.filter(comment => {
                if (!isCodexBot(comment)) {
                  return false;
                }
                const createdAt = new Date(comment.created_at).getTime();
                if (createdAt < cutoff) {
                  return false;
                }
                const body = comment.body || '';
                return body.includes(`<!-- codex:${purpose} `);
              });

              if (recentBotInvocations.length > 0) {
                console.log(`Recent Codex bot activity detected (<5m) for purpose '${purpose}'. Skipping to avoid spam.`);
                return;
              }

              const { data: latestIssueComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                per_page: 50
              });

              const duplicateOnLastPage = latestIssueComments.some(comment => (comment.body || '').includes(marker));
              if (duplicateOnLastPage) {
                console.log('A matching Codex comment appeared while preparing to post. Skipping to avoid duplicates.');
                return;
              }

              const body = [marker, normalizedCommentBody].join('\n');

              console.log(`Posting comment for purpose '${purpose}': ${normalizedCommentBody}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body
              });
              console.log('Comment posted successfully!');
            } else {
              console.log('No action needed. PR looks good!');
            }

            const readyToMerge = !hasFailures && !hasReviewComments && !pr.draft;
            core.setOutput('ready', String(readyToMerge));
            core.setOutput('pr', String(pr_number));
            console.log(`Ready for auto-merge: ${readyToMerge}`);

      - name: Enable native auto-merge
        if: steps.eval.outputs.ready == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.PR_AGENT_TOKEN || github.token }}
          pull-request-number: ${{ steps.eval.outputs.pr }}
          merge-method: merge
